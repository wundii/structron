<?php

declare(strict_types=1);

namespace Wundii\Structron\Resolver;

use RuntimeException;
use Symfony\Component\Filesystem\Filesystem;
use Wundii\Structron\Config\OptionEnum;
use Wundii\Structron\Config\StructronConfig;
use Wundii\Structron\Dto\ColumnsMaxLength;
use Wundii\Structron\Dto\StructronCollectionDto;
use Wundii\Structron\Enum\StructronRowTypEnum;

final readonly class StructronDocsResolver
{
    public function __construct(
        private StructronConfig $structronConfig,
        private Filesystem $filesystem,
    ) {
    }

    public function resolve(StructronCollectionDto $structronCollectionDto): bool
    {
        if ($structronCollectionDto->getStructronFileDtos() === []) {
            return false;
        }

        $mode = 0755;
        $user = 1000;
        $docPath = $this->structronConfig->getString(OptionEnum::DOC_PATH);
        $dtoPaths = $this->structronConfig->getArrayWithStrings(OptionEnum::PATHS);
        $phpExtension = $this->structronConfig->getString(OptionEnum::PHP_EXTENSION);
        $directoryPath = getcwd() . DIRECTORY_SEPARATOR . $docPath;
        if ($this->structronConfig->getBoolean(OptionEnum::TEST)) {
            $directoryPath = '/tmp/' . $docPath;
            $mode = 0777;
            $user = 0;
            @mkdir($directoryPath, $mode, true);
        }

        $markdownStructronFile = $directoryPath . DIRECTORY_SEPARATOR . '_Structron.md';
        $projectStructronFilePath = str_replace($directoryPath, '', $markdownStructronFile);

        if (! $this->filesystem->exists($directoryPath)) {
            $this->filesystem->mkdir($directoryPath, $mode);
            $this->filesystem->chown($directoryPath, $user, true);
        }

        $structronFileContent = '# Structron Documentation' . PHP_EOL;
        $structronFileContent .= 'This documentation is automatically generated by Structron.' . PHP_EOL . PHP_EOL;
        $structronFileContent .= '## Files' . PHP_EOL;
        $structronFileContent .= '| File | Properties |' . PHP_EOL;
        $structronFileContent .= '| ---- | ---------: |' . PHP_EOL;

        foreach ($structronCollectionDto->getStructronFileDtos() as $structronFileDto) {
            $basename = basename($structronFileDto->getPathname());
            $nativeName = str_replace('.' . $phpExtension, '', $basename);
            $projectFilePath = str_replace((string) getcwd(), '', $structronFileDto->getPathname());

            $folder = str_replace($dtoPaths, [''], $structronFileDto->getPathname());
            $folder = str_replace(getcwd() . DIRECTORY_SEPARATOR, '', $folder);
            $folder = str_replace($basename, '', $folder);
            $folder = substr($folder, 1);

            $folderCount = substr_count($folder, DIRECTORY_SEPARATOR);

            $structronReturnPath = '.' . str_repeat('/..', $folderCount);
            $fileReturnPath = '.' . str_repeat('/..', $folderCount + 1);

            $directoryPathDocs = $directoryPath;
            if ($folderCount) {
                $directoryPathDocs .= DIRECTORY_SEPARATOR . $folder;
            }

            if (! $this->filesystem->exists($directoryPathDocs)) {
                $this->filesystem->mkdir($directoryPathDocs, $mode);
                $this->filesystem->chown($directoryPathDocs, $user, true);
            }

            $columnsMaxLength = new ColumnsMaxLength(0, 4, 7, 11);
            $classGlossary = [];

            foreach ($structronFileDto->getCollection() as $structronRowDto) {
                if ($structronRowDto->getTypeRawIfClass()) {
                    $classGlossary[$structronRowDto->getTypeRawIfClass()] = $structronRowDto->getTypeRaw();
                }

                $columnsMaxLength->name = max($columnsMaxLength->name, strlen($structronRowDto->getName()));
                $columnsMaxLength->type = max($columnsMaxLength->type, strlen($structronRowDto->getType()));
                $columnsMaxLength->default = max($columnsMaxLength->default, strlen((string) $structronRowDto->getDefault()));
                $columnsMaxLength->description = max($columnsMaxLength->description, strlen($structronRowDto->getDescription()));
            }

            $fileContent = '# ' . $structronFileDto->getClassname() . PHP_EOL;
            $fileContent .= '- [Back to Structron Documentation](' . $structronReturnPath . $projectStructronFilePath . ')' . PHP_EOL;
            $fileContent .= '- [Go to ' . $basename . '](' . $fileReturnPath . $projectFilePath . ')' . PHP_EOL . PHP_EOL;
            foreach ($structronFileDto->getDescriptions() as $description) {
                $fileContent .= $description . PHP_EOL . PHP_EOL;
            }

            if ($classGlossary !== []) {
                $fileContent .= '## Class glossary' . PHP_EOL;
                $fileContent .= '| FullObjectName | Object |' . PHP_EOL;
                $fileContent .= '| -------------- | ------ |' . PHP_EOL;

                ksort($classGlossary);
                foreach ($classGlossary as $classFullName => $className) {
                    $fileContent .= '| ' . $classFullName . ' | ' . $className . ' |' . PHP_EOL;
                }

                $fileContent .= PHP_EOL;
            }

            $fileContent .= '## Properties' . PHP_EOL;

            foreach ($structronFileDto->getCollection() as $structronRowDto) {
                if ($structronRowDto->getStructronRowTypEnum() === StructronRowTypEnum::HEADER) {
                    $fileContent .= '| ' . str_pad($structronRowDto->getName(), $columnsMaxLength->name) . ' | ';
                    $fileContent .= str_pad('Type', $columnsMaxLength->type) . ' | ';
                    $fileContent .= str_pad('Default', $columnsMaxLength->default) . ' | ';
                    $fileContent .= str_pad('Description', $columnsMaxLength->description) . ' |' . PHP_EOL;

                    $fileContent .= '| ' . str_repeat('-', $columnsMaxLength->name) . ' | ';
                    $fileContent .= str_repeat('-', $columnsMaxLength->type) . ' | ';
                    $fileContent .= str_repeat('-', $columnsMaxLength->default) . ' | ';
                    $fileContent .= str_repeat('-', $columnsMaxLength->description) . ' |' . PHP_EOL;

                    continue;
                }

                $name = $structronRowDto->getStructronRowTypEnum() === StructronRowTypEnum::SUBHEADER
                    ? '**' . $structronRowDto->getName() . '**'
                    : $structronRowDto->getName();

                $fileContent .= '| ' . str_pad($name, $columnsMaxLength->name) . ' | ';
                $fileContent .= str_pad($structronRowDto->getType(), $columnsMaxLength->type) . ' | ';
                $fileContent .= str_pad((string) $structronRowDto->getDefault(), $columnsMaxLength->default) . ' | ';
                $fileContent .= str_pad($structronRowDto->getDescription(), $columnsMaxLength->description) . ' |' . PHP_EOL;
            }

            $markdownFile = $directoryPathDocs . DIRECTORY_SEPARATOR . sprintf('%s.md', $nativeName);
            $filePutContent = file_put_contents($markdownFile, $fileContent);
            if ($filePutContent === false) {
                throw new RuntimeException(sprintf('Could not write to file %s', $markdownFile));
            }

            $this->filesystem->chmod($markdownFile, $mode);
            $this->filesystem->chown($markdownFile, $user);

            $structronFileContent .= '|[' . $structronFileDto->getClassname() . '](' . $folder . $nativeName . '.md)|' . count($structronFileDto->getCollection()) . '|' . PHP_EOL;
        }

        $filePutContent = file_put_contents($markdownStructronFile, $structronFileContent);
        if ($filePutContent === false) {
            throw new RuntimeException(sprintf('Could not write to file %s', $markdownStructronFile));
        }

        $this->filesystem->chmod($markdownStructronFile, $mode);
        $this->filesystem->chown($markdownStructronFile, $user);

        return true;
    }
}
